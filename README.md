# Curiosity-Modeling

1. Project Objective: What are you trying to model? Include a brief description that would give someone unfamiliar with the topic a basic understanding of your goal.

We are attempting to model a round of Texas Hold'em, a variation of Poker. Our model includes having multiple players be dealt cards, then progressed through multiple different round states (including PreFlop, PostFlop, PostTurn, PostRiver) where the dealer reveals cards for the players by putting the cards on the boards, and all of the players have the opportunity to perform an action, such as raise, call or fold. If after all players have performed an action during the PostRiver state, we then evaluate the hands of the remaining players to determine a winner.

To Note: We are planning on continuing and improving the model as our Final Project. There are currently parts to this model not 100% functional that we plan to fix, and there are aspects of a real game of Texas Hold'em that we are yet to implement. Additionally, we would like to create a custom visualizer as the default visualizer is very messy for this model.

2. Model Design and Visualization: Give an overview of your model design choices, what checks or run statements you wrote, and what we should expect to see from an instance produced by the Sterling visualizer. How should we look at and interpret an instance created by your spec? Did you create a custom visualization, or did you use the default?

We are using the default visualizer as it would have been a massive undertaking to both model Poker and create a custom visualizer for this project. This is something we intend to do when we continue this project as our final project. Our run statement calls wellformedCards, playerRotation, evaluateHandRun, and our traces predicates. You can expect to see an absolute ton of data from an instance produced by the default visualizer, making the table page often more readable than the graph page. On the table page you will see all of our sigs that will be filled with values. By taking a look at the rank and suit sig table you can see all of the cards generated by the instance. Additionally, if you take a look at the deck, board and hands (this is easier to look at on the graph page), you can track where all of the cards are in the game. The final main aspect is the bets and actions of the players, which can be tracked by the highestBet, pot and bet fields. 

We do acknowledge that there are current bugs in our model, mainly regarding the betting actions of the game, as highestBet is sometimes larger than possible, and the bet field does not properly update. Additionally, sometimes the board can have an incorrect number of cards for that specific state. We have tried to fix both, but unfortunately so far have had no luck 

3. Signatures and Predicates: At a high level, what do each of your sigs and preds represent in the context of the model? Justify the purpose for their existence and how they fit together.

SIGS: Our first sig is RoundState, which contains all of the players, the deck, the board, the pot, the current highest bet, the currentTurn, and the next state. This sig tracks the current state of the round with the highest bet, the board and which players remain, and ensures a valid transition to the next state. The RoundState sig is actually an abstract sig and we have several one time sigs that the RoundState can be one of, these are preFlop, postFlop, postTurn, and postRiver. The next sig is Card, which has fields of rank and suit, which are also sigs. These 3 sigs aim to replicate a regular card from a deck. The last major sig is Player, which has fields of hand (an abstract sig which could be any of the types of poker hands: pair, flush, straight, ... etc), chips (the value of the chips they have remaining), bet (their current bet on the round), and the next player on the board. This sig attempts to emulate a real person sitting at a poker table. 

PREDICATES: 
The first predicate in our run statement is wellformedCards. This predicate ensures that the deck, the board, and all player hands are formed correctly at all times, namely it restricts the number of cards for each sig, that there is no overlap of cards between sigs, and that all cards are unique. The next predicate in the run statement is playerRotation, this predicate ensures that there is a cycle between all players so that players taking turns works correctly in our model. The next predicate in our run statement is evaluateHand. This predicate calls upon all of our predicates that check what type of hand a player has (hasHighCard, hasRoyalFlush, hasStraightFlush, hasFourOfaKind, hasFullHouse, hasFlush, hasStraight, hasThreeofaKind, hasTwoPair, hasPair), when one of these predicate returns true on a players hand, the score associated with that hand is updated. This predicate is how we know how to rank all players hands. The final predicate in our run statement is traces, which is the main engine of how our model works. Inside of traces we call the predicates initRound, winner and validTransition. initRound is our predicate that initializes the round, inside of this predicate we ensure the board is empty, the highest bet and pot are 0, the players are dealt cards (with our dealCards predicate), the players have the correct amount of chips, and the turn is set to the first player. Next, the winner predicate sets the constraints for a player to win, namely: a player must either be the last remaining player or have the best hand at the end of the round. The final predicate called in traces is validTransition, this predicate calls validTurn for all players and then updates the state, making sure the correct number of cards and the correct cards are moved from the deck to the board. The validTurn predicate calls the canPlay, playerAction, and playerFolds predicates before passing the turn to the next player. The canPlay predicate ensures that the current player is able to play, either his bet is equal to the highest bet or he has remaining chips. The playerAction is all of the predicates a player has to make an action that isn't folding (playerChecks, playerCalls, playerRaises, playerAllIns), if one of these is not called then the player folds and playerFolds is called. That wraps up all of the major predicates in our model. There is an instance that we use to optimize our run calls that simply improves the speed converting a card's rank to its value. 

4. Testing: What tests did you write to test your model itself? What tests did you write to verify properties about your domain area? Feel free to give a high-level overview of this.

We have written a test suite for every predicate of the model, where we test situations where the predicate conditions are met, and where they are not. For dealCards, we make sure that every player has two cards and that the cards are different. For initRound, we make sure that the fields of the RoundStates are set accordingly, and that all players have the correct amount of chips. For winner, we check the hands of the players, or if there is only one player left on the round, then we give the chips. For validTurn we check if the player canPlay and make sure that he does an action. For validTransition we check that the board of the states are correct(have the correct number of cards), and if there was a valid turn. For canPlay, we test if its the players turn, if it is in the game, and if he has chips. For all the action predicates, we test if the player can do the action, and if the action is done correctly. For the hand predicates, we test if the player has the hand, and if he does not. For the evaluateHand predicate, we test if the player has the correct hand. For the wellformedCards predicate, we check that there are no repeated cards between the deck, the board and the players hands. For the playerRotation predicate, we check that all the players are reachable through the nextPlayer function. As most of the predicates have both elements, the model itself and the domain that we want that model to have,  and we have tested basically every condition possible in the predicates, then we have tests for both the model and the domain.

There is a note in the testing file. Please read.

5. Documentation: Make sure your model and test files are well-documented. This will help in understanding the structure and logic of your project.

We have added documentation to every single sig, predicate, and test suite to ensure that our model and test file is well-documented. 